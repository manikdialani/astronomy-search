{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n// src/dom/methods/hasClass.ts\nfunction hasClass(element, className) {\n  if (element) {\n    if (element.classList) return element.classList.contains(className);else return new RegExp(\"(^| )\" + className + \"( |$)\", \"gi\").test(element.className);\n  }\n  return false;\n}\n\n// src/dom/methods/addClass.ts\nfunction addClass(element, className) {\n  if (element && className) {\n    const fn = _className => {\n      if (!hasClass(element, _className)) {\n        if (element.classList) element.classList.add(_className);else element.className += \" \" + _className;\n      }\n    };\n    [className].flat().filter(Boolean).forEach(_classNames => _classNames.split(\" \").forEach(fn));\n  }\n}\n\n// src/dom/methods/calculateBodyScrollbarWidth.ts\nfunction calculateBodyScrollbarWidth() {\n  return window.innerWidth - document.documentElement.offsetWidth;\n}\n\n// src/dom/methods/getCSSVariableByRegex.ts\nfunction getCSSVariableByRegex(variableRegex) {\n  for (const sheet of document == null ? void 0 : document.styleSheets) {\n    try {\n      for (const rule of sheet == null ? void 0 : sheet.cssRules) {\n        for (const property of rule == null ? void 0 : rule.style) {\n          if (variableRegex.test(property)) {\n            return {\n              name: property,\n              value: rule.style.getPropertyValue(property).trim()\n            };\n          }\n        }\n      }\n    } catch (e) {}\n  }\n  return null;\n}\n\n// src/dom/helpers/blockBodyScroll.ts\nfunction blockBodyScroll(className = \"p-overflow-hidden\") {\n  const variableData = getCSSVariableByRegex(/-scrollbar-width$/);\n  (variableData == null ? void 0 : variableData.name) && document.body.style.setProperty(variableData.name, calculateBodyScrollbarWidth() + \"px\");\n  addClass(document.body, className);\n}\n\n// src/dom/helpers/saveAs.ts\nfunction saveAs(file) {\n  if (file) {\n    let link = document.createElement(\"a\");\n    if (link.download !== void 0) {\n      const {\n        name,\n        src\n      } = file;\n      link.setAttribute(\"href\", src);\n      link.setAttribute(\"download\", name);\n      link.style.display = \"none\";\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/dom/helpers/exportCSV.ts\nfunction exportCSV(csv, filename) {\n  let blob = new Blob([csv], {\n    type: \"application/csv;charset=utf-8;\"\n  });\n  if (window.navigator.msSaveOrOpenBlob) {\n    navigator.msSaveOrOpenBlob(blob, filename + \".csv\");\n  } else {\n    const isDownloaded = saveAs({\n      name: filename + \".csv\",\n      src: URL.createObjectURL(blob)\n    });\n    if (!isDownloaded) {\n      csv = \"data:text/csv;charset=utf-8,\" + csv;\n      window.open(encodeURI(csv));\n    }\n  }\n}\n\n// src/dom/methods/removeClass.ts\nfunction removeClass(element, className) {\n  if (element && className) {\n    const fn = _className => {\n      if (element.classList) element.classList.remove(_className);else element.className = element.className.replace(new RegExp(\"(^|\\\\b)\" + _className.split(\" \").join(\"|\") + \"(\\\\b|$)\", \"gi\"), \" \");\n    };\n    [className].flat().filter(Boolean).forEach(_classNames => _classNames.split(\" \").forEach(fn));\n  }\n}\n\n// src/dom/helpers/unblockBodyScroll.ts\nfunction unblockBodyScroll(className = \"p-overflow-hidden\") {\n  const variableData = getCSSVariableByRegex(/-scrollbar-width$/);\n  (variableData == null ? void 0 : variableData.name) && document.body.style.removeProperty(variableData.name);\n  removeClass(document.body, className);\n}\n\n// src/dom/methods/getHiddenElementDimensions.ts\nfunction getHiddenElementDimensions(element) {\n  let dimensions = {\n    width: 0,\n    height: 0\n  };\n  if (element) {\n    element.style.visibility = \"hidden\";\n    element.style.display = \"block\";\n    dimensions.width = element.offsetWidth;\n    dimensions.height = element.offsetHeight;\n    element.style.display = \"none\";\n    element.style.visibility = \"visible\";\n  }\n  return dimensions;\n}\n\n// src/dom/methods/getViewport.ts\nfunction getViewport() {\n  let win = window,\n    d = document,\n    e = d.documentElement,\n    g = d.getElementsByTagName(\"body\")[0],\n    w = win.innerWidth || e.clientWidth || g.clientWidth,\n    h = win.innerHeight || e.clientHeight || g.clientHeight;\n  return {\n    width: w,\n    height: h\n  };\n}\n\n// src/dom/methods/getWindowScrollLeft.ts\nfunction getWindowScrollLeft() {\n  let doc = document.documentElement;\n  return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n}\n\n// src/dom/methods/getWindowScrollTop.ts\nfunction getWindowScrollTop() {\n  let doc = document.documentElement;\n  return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n}\n\n// src/dom/methods/absolutePosition.ts\nfunction absolutePosition(element, target, gutter = true) {\n  var _a, _b, _c, _d;\n  if (element) {\n    const elementDimensions = element.offsetParent ? {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    } : getHiddenElementDimensions(element);\n    const elementOuterHeight = elementDimensions.height;\n    const elementOuterWidth = elementDimensions.width;\n    const targetOuterHeight = target.offsetHeight;\n    const targetOuterWidth = target.offsetWidth;\n    const targetOffset = target.getBoundingClientRect();\n    const windowScrollTop = getWindowScrollTop();\n    const windowScrollLeft = getWindowScrollLeft();\n    const viewport = getViewport();\n    let top,\n      left,\n      origin = \"top\";\n    if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {\n      top = targetOffset.top + windowScrollTop - elementOuterHeight;\n      origin = \"bottom\";\n      if (top < 0) {\n        top = windowScrollTop;\n      }\n    } else {\n      top = targetOuterHeight + targetOffset.top + windowScrollTop;\n    }\n    if (targetOffset.left + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);else left = targetOffset.left + windowScrollLeft;\n    element.style.top = top + \"px\";\n    element.style.left = left + \"px\";\n    element.style.transformOrigin = origin;\n    gutter && (element.style.marginTop = origin === \"bottom\" ? `calc(${(_b = (_a = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a.value) != null ? _b : \"2px\"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : \"\");\n  }\n}\n\n// src/dom/methods/addStyle.ts\nfunction addStyle(element, style) {\n  if (element) {\n    if (typeof style === \"string\") {\n      element.style.cssText = style;\n    } else {\n      Object.entries(style || {}).forEach(([key, value]) => element.style[key] = value);\n    }\n  }\n}\n\n// src/dom/methods/getOuterWidth.ts\nfunction getOuterWidth(element, margin) {\n  if (element instanceof HTMLElement) {\n    let width = element.offsetWidth;\n    if (margin) {\n      let style = getComputedStyle(element);\n      width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    }\n    return width;\n  }\n  return 0;\n}\n\n// src/dom/methods/relativePosition.ts\nfunction relativePosition(element, target, gutter = true) {\n  var _a, _b, _c, _d;\n  if (element) {\n    const elementDimensions = element.offsetParent ? {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    } : getHiddenElementDimensions(element);\n    const targetHeight = target.offsetHeight;\n    const targetOffset = target.getBoundingClientRect();\n    const viewport = getViewport();\n    let top,\n      left,\n      origin = \"top\";\n    if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {\n      top = -1 * elementDimensions.height;\n      origin = \"bottom\";\n      if (targetOffset.top + top < 0) {\n        top = -1 * targetOffset.top;\n      }\n    } else {\n      top = targetHeight;\n    }\n    if (elementDimensions.width > viewport.width) {\n      left = targetOffset.left * -1;\n    } else if (targetOffset.left + elementDimensions.width > viewport.width) {\n      left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;\n    } else {\n      left = 0;\n    }\n    element.style.top = top + \"px\";\n    element.style.left = left + \"px\";\n    element.style.transformOrigin = origin;\n    gutter && (element.style.marginTop = origin === \"bottom\" ? `calc(${(_b = (_a = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a.value) != null ? _b : \"2px\"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : \"\");\n  }\n}\n\n// src/dom/methods/alignOverlay.ts\nfunction alignOverlay(overlay, target, appendTo, calculateMinWidth = true) {\n  if (overlay && target) {\n    if (appendTo === \"self\") {\n      relativePosition(overlay, target);\n    } else {\n      calculateMinWidth && (overlay.style.minWidth = getOuterWidth(target) + \"px\");\n      absolutePosition(overlay, target);\n    }\n  }\n}\n\n// src/dom/methods/isElement.ts\nfunction isElement(element) {\n  return typeof HTMLElement === \"object\" ? element instanceof HTMLElement : element && typeof element === \"object\" && element !== null && element.nodeType === 1 && typeof element.nodeName === \"string\";\n}\n\n// src/dom/methods/toElement.ts\nfunction toElement(element) {\n  let target = element;\n  if (element && typeof element === \"object\") {\n    if (element.hasOwnProperty(\"current\")) {\n      target = element.current;\n    } else if (element.hasOwnProperty(\"el\")) {\n      if (element.el.hasOwnProperty(\"nativeElement\")) {\n        target = element.el.nativeElement;\n      } else {\n        target = element.el;\n      }\n    }\n  }\n  return isElement(target) ? target : void 0;\n}\n\n// src/dom/methods/appendChild.ts\nfunction appendChild(element, child) {\n  const target = toElement(element);\n  if (target) target.appendChild(child);else throw new Error(\"Cannot append \" + child + \" to \" + element);\n}\n\n// src/dom/methods/calculateScrollbarHeight.ts\nvar calculatedScrollbarHeight = void 0;\nfunction calculateScrollbarHeight(element) {\n  if (element) {\n    let style = getComputedStyle(element);\n    return element.offsetHeight - element.clientHeight - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth);\n  } else {\n    if (calculatedScrollbarHeight != null) return calculatedScrollbarHeight;\n    let scrollDiv = document.createElement(\"div\");\n    addStyle(scrollDiv, {\n      width: \"100px\",\n      height: \"100px\",\n      overflow: \"scroll\",\n      position: \"absolute\",\n      top: \"-9999px\"\n    });\n    document.body.appendChild(scrollDiv);\n    let scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;\n    document.body.removeChild(scrollDiv);\n    calculatedScrollbarHeight = scrollbarHeight;\n    return scrollbarHeight;\n  }\n}\n\n// src/dom/methods/calculateScrollbarWidth.ts\nvar calculatedScrollbarWidth = void 0;\nfunction calculateScrollbarWidth(element) {\n  if (element) {\n    let style = getComputedStyle(element);\n    return element.offsetWidth - element.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);\n  } else {\n    if (calculatedScrollbarWidth != null) return calculatedScrollbarWidth;\n    let scrollDiv = document.createElement(\"div\");\n    addStyle(scrollDiv, {\n      width: \"100px\",\n      height: \"100px\",\n      overflow: \"scroll\",\n      position: \"absolute\",\n      top: \"-9999px\"\n    });\n    document.body.appendChild(scrollDiv);\n    let scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    calculatedScrollbarWidth = scrollbarWidth;\n    return scrollbarWidth;\n  }\n}\n\n// src/dom/methods/clearSelection.ts\nfunction clearSelection() {\n  if (window.getSelection) {\n    const selection = window.getSelection() || {};\n    if (selection.empty) {\n      selection.empty();\n    } else if (selection.removeAllRanges && selection.rangeCount > 0 && selection.getRangeAt(0).getClientRects().length > 0) {\n      selection.removeAllRanges();\n    }\n  }\n}\n\n// src/dom/methods/setAttributes.ts\nfunction setAttributes(element, attributes = {}) {\n  if (isElement(element)) {\n    const computedStyles = (rule, value) => {\n      var _a, _b;\n      const styles = ((_a = element == null ? void 0 : element.$attrs) == null ? void 0 : _a[rule]) ? [(_b = element == null ? void 0 : element.$attrs) == null ? void 0 : _b[rule]] : [];\n      return [value].flat().reduce((cv, v) => {\n        if (v !== null && v !== void 0) {\n          const type = typeof v;\n          if (type === \"string\" || type === \"number\") {\n            cv.push(v);\n          } else if (type === \"object\") {\n            const _cv = Array.isArray(v) ? computedStyles(rule, v) : Object.entries(v).map(([_k, _v]) => rule === \"style\" && (!!_v || _v === 0) ? `${_k.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase()}:${_v}` : !!_v ? _k : void 0);\n            cv = _cv.length ? cv.concat(_cv.filter(c => !!c)) : cv;\n          }\n        }\n        return cv;\n      }, styles);\n    };\n    Object.entries(attributes).forEach(([key, value]) => {\n      if (value !== void 0 && value !== null) {\n        const matchedEvent = key.match(/^on(.+)/);\n        if (matchedEvent) {\n          element.addEventListener(matchedEvent[1].toLowerCase(), value);\n        } else if (key === \"p-bind\" || key === \"pBind\") {\n          setAttributes(element, value);\n        } else {\n          value = key === \"class\" ? [...new Set(computedStyles(\"class\", value))].join(\" \").trim() : key === \"style\" ? computedStyles(\"style\", value).join(\";\").trim() : value;\n          (element.$attrs = element.$attrs || {}) && (element.$attrs[key] = value);\n          element.setAttribute(key, value);\n        }\n      }\n    });\n  }\n}\n\n// src/dom/methods/createElement.ts\nfunction createElement(type, attributes = {}, ...children) {\n  if (type) {\n    const element = document.createElement(type);\n    setAttributes(element, attributes);\n    element.append(...children);\n    return element;\n  }\n  return void 0;\n}\n\n// src/dom/methods/createStyleAsString.ts\nfunction createStyleAsString(css, options = {}) {\n  return css ? `'<style ${Object.entries(options).reduce((s, [k, v]) => s + `${k}=\"${v}\"`, \" \")}>${css}</style>'` : \"\";\n}\n\n// src/dom/methods/createStyleTag.ts\nfunction createStyleTag(attributes = {}, container) {\n  let element = document.createElement(\"style\");\n  setAttributes(element, attributes);\n  if (!container) {\n    container = document.head;\n  }\n  container.appendChild(element);\n  return element;\n}\n\n// src/dom/methods/fadeIn.ts\nfunction fadeIn(element, duration) {\n  if (element) {\n    element.style.opacity = \"0\";\n    let last = + /* @__PURE__ */new Date();\n    let opacity = \"0\";\n    let tick = function () {\n      opacity = `${+element.style.opacity + ((/* @__PURE__ */new Date()).getTime() - last) / duration}`;\n      element.style.opacity = opacity;\n      last = + /* @__PURE__ */new Date();\n      if (+opacity < 1) {\n        !!window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);\n      }\n    };\n    tick();\n  }\n}\n\n// src/dom/methods/fadeOut.ts\nfunction fadeOut(element, duration) {\n  if (element) {\n    let opacity = 1,\n      interval = 50,\n      gap = interval / duration;\n    let fading = setInterval(() => {\n      opacity -= gap;\n      if (opacity <= 0) {\n        opacity = 0;\n        clearInterval(fading);\n      }\n      element.style.opacity = opacity.toString();\n    }, interval);\n  }\n}\n\n// src/dom/methods/find.ts\nfunction find(element, selector) {\n  return isElement(element) ? Array.from(element.querySelectorAll(selector)) : [];\n}\n\n// src/dom/methods/findSingle.ts\nfunction findSingle(element, selector) {\n  return isElement(element) ? element.matches(selector) ? element : element.querySelector(selector) : null;\n}\n\n// src/dom/methods/focus.ts\nfunction focus(element, options) {\n  element && document.activeElement !== element && element.focus(options);\n}\n\n// src/dom/methods/getAttribute.ts\nfunction getAttribute(element, name) {\n  if (isElement(element)) {\n    const value = element.getAttribute(name);\n    if (!isNaN(value)) {\n      return +value;\n    }\n    if (value === \"true\" || value === \"false\") {\n      return value === \"true\";\n    }\n    return value;\n  }\n  return void 0;\n}\n\n// src/dom/methods/resolveUserAgent.ts\nfunction resolveUserAgent() {\n  let ua = navigator.userAgent.toLowerCase();\n  let match = /(chrome)[ ]([\\w.]+)/.exec(ua) || /(webkit)[ ]([\\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\\w.]+)/.exec(ua) || /(msie) ([\\w.]+)/.exec(ua) || ua.indexOf(\"compatible\") < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua) || [];\n  return {\n    browser: match[1] || \"\",\n    version: match[2] || \"0\"\n  };\n}\n\n// src/dom/methods/getBrowser.ts\nvar browser = null;\nfunction getBrowser() {\n  if (!browser) {\n    browser = {};\n    let matched = resolveUserAgent();\n    if (matched.browser) {\n      browser[matched.browser] = true;\n      browser[\"version\"] = matched.version;\n    }\n    if (browser[\"chrome\"]) {\n      browser[\"webkit\"] = true;\n    } else if (browser[\"webkit\"]) {\n      browser[\"safari\"] = true;\n    }\n  }\n  return browser;\n}\n\n// src/dom/methods/getBrowserLanguage.ts\nfunction getBrowserLanguage() {\n  return navigator.languages && navigator.languages.length && navigator.languages[0] || navigator.language || \"en\";\n}\n\n// src/dom/methods/getCSSProperty.ts\nfunction getCSSProperty(element, property, inline) {\n  var _a;\n  if (element && property) {\n    return inline ? (_a = element == null ? void 0 : element.style) == null ? void 0 : _a.getPropertyValue(property) : getComputedStyle(element).getPropertyValue(property);\n  }\n  return null;\n}\n\n// src/dom/methods/getCursorOffset.ts\nfunction getCursorOffset(element, prevText, nextText, currentText) {\n  if (element) {\n    let style = getComputedStyle(element);\n    let ghostDiv = document.createElement(\"div\");\n    ghostDiv.style.position = \"absolute\";\n    ghostDiv.style.top = \"0px\";\n    ghostDiv.style.left = \"0px\";\n    ghostDiv.style.visibility = \"hidden\";\n    ghostDiv.style.pointerEvents = \"none\";\n    ghostDiv.style.overflow = style.overflow;\n    ghostDiv.style.width = style.width;\n    ghostDiv.style.height = style.height;\n    ghostDiv.style.padding = style.padding;\n    ghostDiv.style.border = style.border;\n    ghostDiv.style.overflowWrap = style.overflowWrap;\n    ghostDiv.style.whiteSpace = style.whiteSpace;\n    ghostDiv.style.lineHeight = style.lineHeight;\n    ghostDiv.innerHTML = prevText.replace(/\\r\\n|\\r|\\n/g, \"<br />\");\n    let ghostSpan = document.createElement(\"span\");\n    ghostSpan.textContent = currentText;\n    ghostDiv.appendChild(ghostSpan);\n    let text = document.createTextNode(nextText);\n    ghostDiv.appendChild(text);\n    document.body.appendChild(ghostDiv);\n    const {\n      offsetLeft,\n      offsetTop,\n      clientHeight\n    } = ghostSpan;\n    document.body.removeChild(ghostDiv);\n    return {\n      left: Math.abs(offsetLeft - element.scrollLeft),\n      top: Math.abs(offsetTop - element.scrollTop) + clientHeight\n    };\n  }\n  return {\n    top: \"auto\",\n    left: \"auto\"\n  };\n}\n\n// src/dom/methods/getFocusableElements.ts\nfunction getFocusableElements(element, selector = \"\") {\n  let focusableElements = find(element, `button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`);\n  let visibleFocusableElements = [];\n  for (let focusableElement of focusableElements) {\n    if (getComputedStyle(focusableElement).display != \"none\" && getComputedStyle(focusableElement).visibility != \"hidden\") visibleFocusableElements.push(focusableElement);\n  }\n  return visibleFocusableElements;\n}\n\n// src/dom/methods/getFirstFocusableElement.ts\nfunction getFirstFocusableElement(element, selector) {\n  const focusableElements = getFocusableElements(element, selector);\n  return focusableElements.length > 0 ? focusableElements[0] : null;\n}\n\n// src/dom/methods/getHeight.ts\nfunction getHeight(element) {\n  if (element) {\n    let height = element.offsetHeight;\n    let style = getComputedStyle(element);\n    height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n    return height;\n  }\n  return 0;\n}\n\n// src/dom/methods/getHiddenElementOuterHeight.ts\nfunction getHiddenElementOuterHeight(element) {\n  if (element) {\n    element.style.visibility = \"hidden\";\n    element.style.display = \"block\";\n    let elementHeight = element.offsetHeight;\n    element.style.display = \"none\";\n    element.style.visibility = \"visible\";\n    return elementHeight;\n  }\n  return 0;\n}\n\n// src/dom/methods/getHiddenElementOuterWidth.ts\nfunction getHiddenElementOuterWidth(element) {\n  if (element) {\n    element.style.visibility = \"hidden\";\n    element.style.display = \"block\";\n    let elementWidth = element.offsetWidth;\n    element.style.display = \"none\";\n    element.style.visibility = \"visible\";\n    return elementWidth;\n  }\n  return 0;\n}\n\n// src/dom/methods/getParentNode.ts\nfunction getParentNode(element) {\n  if (element) {\n    let parent = element.parentNode;\n    if (parent && parent instanceof ShadowRoot && parent.host) {\n      parent = parent.host;\n    }\n    return parent;\n  }\n  return null;\n}\n\n// src/dom/methods/getIndex.ts\nfunction getIndex(element) {\n  var _a;\n  if (element) {\n    let children = (_a = getParentNode(element)) == null ? void 0 : _a.childNodes;\n    let num = 0;\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        if (children[i] === element) return num;\n        if (children[i].nodeType === 1) num++;\n      }\n    }\n  }\n  return -1;\n}\n\n// src/dom/methods/getInnerWidth.ts\nfunction getInnerWidth(element) {\n  if (element) {\n    let width = element.offsetWidth;\n    let style = getComputedStyle(element);\n    width -= parseFloat(style.borderLeft) + parseFloat(style.borderRight);\n    return width;\n  }\n  return 0;\n}\n\n// src/dom/methods/getLastFocusableElement.ts\nfunction getLastFocusableElement(element, selector) {\n  const focusableElements = getFocusableElements(element, selector);\n  return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;\n}\n\n// src/dom/methods/getNextElementSibling.ts\nfunction getNextElementSibling(element, selector) {\n  let nextElement = element.nextElementSibling;\n  while (nextElement) {\n    if (nextElement.matches(selector)) {\n      return nextElement;\n    } else {\n      nextElement = nextElement.nextElementSibling;\n    }\n  }\n  return null;\n}\n\n// src/dom/methods/getNextFocusableElement.ts\nfunction getNextFocusableElement(container, element, selector) {\n  const focusableElements = getFocusableElements(container, selector);\n  const index = focusableElements.length > 0 ? focusableElements.findIndex(el => el === element) : -1;\n  const nextIndex = index > -1 && focusableElements.length >= index + 1 ? index + 1 : -1;\n  return nextIndex > -1 ? focusableElements[nextIndex] : null;\n}\n\n// src/dom/methods/getOffset.ts\nfunction getOffset(element) {\n  if (element) {\n    let rect = element.getBoundingClientRect();\n    return {\n      top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),\n      left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)\n    };\n  }\n  return {\n    top: \"auto\",\n    left: \"auto\"\n  };\n}\n\n// src/dom/methods/getOuterHeight.ts\nfunction getOuterHeight(element, margin) {\n  if (element) {\n    let height = element.offsetHeight;\n    if (margin) {\n      let style = getComputedStyle(element);\n      height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    }\n    return height;\n  }\n  return 0;\n}\n\n// src/dom/methods/getParents.ts\nfunction getParents(element, parents = []) {\n  const parent = getParentNode(element);\n  return parent === null ? parents : getParents(parent, parents.concat([parent]));\n}\n\n// src/dom/methods/getPreviousElementSibling.ts\nfunction getPreviousElementSibling(element, selector) {\n  let previousElement = element.previousElementSibling;\n  while (previousElement) {\n    if (previousElement.matches(selector)) {\n      return previousElement;\n    } else {\n      previousElement = previousElement.previousElementSibling;\n    }\n  }\n  return null;\n}\n\n// src/dom/methods/getScrollableParents.ts\nfunction getScrollableParents(element) {\n  let scrollableParents = [];\n  if (element) {\n    let parents = getParents(element);\n    const overflowRegex = /(auto|scroll)/;\n    const overflowCheck = node => {\n      try {\n        let styleDeclaration = window[\"getComputedStyle\"](node, null);\n        return overflowRegex.test(styleDeclaration.getPropertyValue(\"overflow\")) || overflowRegex.test(styleDeclaration.getPropertyValue(\"overflowX\")) || overflowRegex.test(styleDeclaration.getPropertyValue(\"overflowY\"));\n      } catch (err) {\n        return false;\n      }\n    };\n    for (let parent of parents) {\n      let scrollSelectors = parent.nodeType === 1 && parent.dataset[\"scrollselectors\"];\n      if (scrollSelectors) {\n        let selectors = scrollSelectors.split(\",\");\n        for (let selector of selectors) {\n          let el = findSingle(parent, selector);\n          if (el && overflowCheck(el)) {\n            scrollableParents.push(el);\n          }\n        }\n      }\n      if (parent.nodeType !== 9 && overflowCheck(parent)) {\n        scrollableParents.push(parent);\n      }\n    }\n  }\n  return scrollableParents;\n}\n\n// src/dom/methods/getSelection.ts\nfunction getSelection() {\n  if (window.getSelection) return window.getSelection().toString();else if (document.getSelection) return document.getSelection().toString();\n  return void 0;\n}\n\n// src/dom/methods/isExist.ts\nfunction isExist(element) {\n  return !!(element !== null && typeof element !== \"undefined\" && element.nodeName && getParentNode(element));\n}\n\n// src/dom/methods/getTargetElement.ts\nfunction getTargetElement(target, currentElement) {\n  var _a;\n  if (!target) return void 0;\n  switch (target) {\n    case \"document\":\n      return document;\n    case \"window\":\n      return window;\n    case \"body\":\n      return document.body;\n    case \"@next\":\n      return currentElement == null ? void 0 : currentElement.nextElementSibling;\n    case \"@prev\":\n      return currentElement == null ? void 0 : currentElement.previousElementSibling;\n    case \"@parent\":\n      return currentElement == null ? void 0 : currentElement.parentElement;\n    case \"@grandparent\":\n      return (_a = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a.parentElement;\n    default:\n      if (typeof target === \"string\") {\n        return document.querySelector(target);\n      }\n      const isFunction = obj => !!(obj && obj.constructor && obj.call && obj.apply);\n      const element = toElement(isFunction(target) ? target() : target);\n      return (element == null ? void 0 : element.nodeType) === 9 || isExist(element) ? element : void 0;\n  }\n}\n\n// src/dom/methods/getUserAgent.ts\nfunction getUserAgent() {\n  return navigator.userAgent;\n}\n\n// src/dom/methods/getWidth.ts\nfunction getWidth(element) {\n  if (element) {\n    let width = element.offsetWidth;\n    let style = getComputedStyle(element);\n    width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);\n    return width;\n  }\n  return 0;\n}\n\n// src/dom/methods/hasCSSAnimation.ts\nfunction hasCSSAnimation(element) {\n  if (element) {\n    const style = getComputedStyle(element);\n    const animationDuration = parseFloat(style.getPropertyValue(\"animation-duration\") || \"0\");\n    return animationDuration > 0;\n  }\n  return false;\n}\n\n// src/dom/methods/hasCSSTransition.ts\nfunction hasCSSTransition(element) {\n  if (element) {\n    const style = getComputedStyle(element);\n    const transitionDuration = parseFloat(style.getPropertyValue(\"transition-duration\") || \"0\");\n    return transitionDuration > 0;\n  }\n  return false;\n}\n\n// src/dom/methods/invokeElementMethod.ts\nfunction invokeElementMethod(element, methodName, args) {\n  element[methodName].apply(element, args);\n}\n\n// src/dom/methods/isAndroid.ts\nfunction isAndroid() {\n  return /(android)/i.test(navigator.userAgent);\n}\n\n// src/dom/methods/isAttributeEquals.ts\nfunction isAttributeEquals(element, name, value) {\n  return isElement(element) ? getAttribute(element, name) === value : false;\n}\n\n// src/dom/methods/isAttributeNotEquals.ts\nfunction isAttributeNotEquals(element, name, value) {\n  return !isAttributeEquals(element, name, value);\n}\n\n// src/dom/methods/isClickable.ts\nfunction isClickable(element) {\n  if (element) {\n    const targetNode = element.nodeName;\n    const parentNode = element.parentElement && element.parentElement.nodeName;\n    return targetNode === \"INPUT\" || targetNode === \"TEXTAREA\" || targetNode === \"BUTTON\" || targetNode === \"A\" || parentNode === \"INPUT\" || parentNode === \"TEXTAREA\" || parentNode === \"BUTTON\" || parentNode === \"A\" || !!element.closest(\".p-button, .p-checkbox, .p-radiobutton\");\n  }\n  return false;\n}\n\n// src/dom/methods/isClient.ts\nfunction isClient() {\n  return !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n}\n\n// src/dom/methods/isFocusableElement.ts\nfunction isFocusableElement(element, selector = \"\") {\n  return isElement(element) ? element.matches(`button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`) : false;\n}\n\n// src/dom/methods/isVisible.ts\nfunction isVisible(element) {\n  return !!(element && element.offsetParent != null);\n}\n\n// src/dom/methods/isHidden.ts\nfunction isHidden(element) {\n  return !isVisible(element);\n}\n\n// src/dom/methods/isIOS.ts\nfunction isIOS() {\n  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window[\"MSStream\"];\n}\n\n// src/dom/methods/isRTL.ts\nfunction isRTL(element) {\n  return element ? getComputedStyle(element).direction === \"rtl\" : false;\n}\n\n// src/dom/methods/isServer.ts\nfunction isServer() {\n  return !isClient();\n}\n\n// src/dom/methods/isTouchDevice.ts\nfunction isTouchDevice() {\n  return \"ontouchstart\" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\n}\n\n// src/dom/methods/nestedPosition.ts\nfunction nestedPosition(element, level) {\n  var _a, _b;\n  if (element) {\n    const parentItem = element.parentElement;\n    const elementOffset = getOffset(parentItem);\n    const viewport = getViewport();\n    const sublistWidth = element.offsetParent ? element.offsetWidth : getHiddenElementOuterWidth(element);\n    const sublistHeight = element.offsetParent ? element.offsetHeight : getHiddenElementOuterHeight(element);\n    const itemOuterWidth = getOuterWidth((_a = parentItem == null ? void 0 : parentItem.children) == null ? void 0 : _a[0]);\n    const itemOuterHeight = getOuterHeight((_b = parentItem == null ? void 0 : parentItem.children) == null ? void 0 : _b[0]);\n    let left = \"\";\n    let top = \"\";\n    if (elementOffset.left + itemOuterWidth + sublistWidth > viewport.width - calculateScrollbarWidth()) {\n      if (elementOffset.left < sublistWidth) {\n        if (level % 2 === 1) {\n          left = elementOffset.left ? \"-\" + elementOffset.left + \"px\" : \"100%\";\n        } else if (level % 2 === 0) {\n          left = viewport.width - sublistWidth - calculateScrollbarWidth() + \"px\";\n        }\n      } else {\n        left = \"-100%\";\n      }\n    } else {\n      left = \"100%\";\n    }\n    if (element.getBoundingClientRect().top + itemOuterHeight + sublistHeight > viewport.height) {\n      top = `-${sublistHeight - itemOuterHeight}px`;\n    } else {\n      top = \"0px\";\n    }\n    element.style.top = top;\n    element.style.left = left;\n  }\n}\n\n// src/dom/methods/remove.ts\nfunction remove(element) {\n  var _a;\n  if (element) {\n    if (!(\"remove\" in Element.prototype)) (_a = element.parentNode) == null ? void 0 : _a.removeChild(element);else element.remove();\n  }\n}\n\n// src/dom/methods/removeChild.ts\nfunction removeChild(element, child) {\n  const target = toElement(element);\n  if (target) target.removeChild(child);else throw new Error(\"Cannot remove \" + child + \" from \" + element);\n}\n\n// src/dom/methods/removeStyleTag.ts\nfunction removeStyleTag(element) {\n  var _a;\n  if (isExist(element)) {\n    try {\n      (_a = element.parentNode) == null ? void 0 : _a.removeChild(element);\n    } catch (error) {}\n    return null;\n  }\n  return element;\n}\n\n// src/dom/methods/scrollInView.ts\nfunction scrollInView(container, item) {\n  let borderTopValue = getComputedStyle(container).getPropertyValue(\"borderTopWidth\");\n  let borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;\n  let paddingTopValue = getComputedStyle(container).getPropertyValue(\"paddingTop\");\n  let paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;\n  let containerRect = container.getBoundingClientRect();\n  let itemRect = item.getBoundingClientRect();\n  let offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;\n  let scroll = container.scrollTop;\n  let elementHeight = container.clientHeight;\n  let itemHeight = getOuterHeight(item);\n  if (offset < 0) {\n    container.scrollTop = scroll + offset;\n  } else if (offset + itemHeight > elementHeight) {\n    container.scrollTop = scroll + offset - elementHeight + itemHeight;\n  }\n}\n\n// src/dom/methods/setAttribute.ts\nfunction setAttribute(element, attribute = \"\", value) {\n  if (isElement(element) && value !== null && value !== void 0) {\n    element.setAttribute(attribute, value);\n  }\n}\n\n// src/dom/methods/setCSSProperty.ts\nfunction setCSSProperty(element, property, value = null, priority) {\n  var _a;\n  property && ((_a = element == null ? void 0 : element.style) == null ? void 0 : _a.setProperty(property, value, priority));\n}\nexport { absolutePosition, addClass, addStyle, alignOverlay, appendChild, blockBodyScroll, calculateBodyScrollbarWidth, calculateScrollbarHeight, calculateScrollbarWidth, clearSelection, createElement, createStyleAsString, createStyleTag, exportCSV, fadeIn, fadeOut, find, findSingle, focus, getAttribute, getBrowser, getBrowserLanguage, getCSSProperty, getCSSVariableByRegex, getCursorOffset, getFirstFocusableElement, getFocusableElements, getHeight, getHiddenElementDimensions, getHiddenElementOuterHeight, getHiddenElementOuterWidth, getIndex, getInnerWidth, getLastFocusableElement, getNextElementSibling, getNextFocusableElement, getOffset, getOuterHeight, getOuterWidth, getParentNode, getParents, getPreviousElementSibling, getScrollableParents, getSelection, getTargetElement, getUserAgent, getViewport, getWidth, getWindowScrollLeft, getWindowScrollTop, hasCSSAnimation, hasCSSTransition, hasClass, invokeElementMethod, isAndroid, isAttributeEquals, isAttributeNotEquals, isClickable, isClient, isElement, isExist, isFocusableElement, isHidden, isIOS, isRTL, isServer, isTouchDevice, isVisible, nestedPosition, relativePosition, remove, removeChild, removeClass, removeStyleTag, resolveUserAgent, saveAs, scrollInView, setAttribute, setAttributes, setCSSProperty, toElement, unblockBodyScroll };","map":{"version":3,"names":["hasClass","element","className","classList","contains","RegExp","test","addClass","fn","_className","add","flat","filter","Boolean","forEach","_classNames","split","calculateBodyScrollbarWidth","window","innerWidth","document","documentElement","offsetWidth","getCSSVariableByRegex","variableRegex","sheet","styleSheets","rule","cssRules","property","style","name","value","getPropertyValue","trim","e","blockBodyScroll","variableData","body","setProperty","saveAs","file","link","createElement","download","src","setAttribute","display","appendChild","click","removeChild","exportCSV","csv","filename","blob","Blob","type","navigator","msSaveOrOpenBlob","isDownloaded","URL","createObjectURL","open","encodeURI","removeClass","remove","replace","join","unblockBodyScroll","removeProperty","getHiddenElementDimensions","dimensions","width","height","visibility","offsetHeight","getViewport","win","d","g","getElementsByTagName","w","clientWidth","h","innerHeight","clientHeight","getWindowScrollLeft","doc","pageXOffset","scrollLeft","clientLeft","getWindowScrollTop","pageYOffset","scrollTop","clientTop","absolutePosition","target","gutter","_a","_b","_c","_d","elementDimensions","offsetParent","elementOuterHeight","elementOuterWidth","targetOuterHeight","targetOuterWidth","targetOffset","getBoundingClientRect","windowScrollTop","windowScrollLeft","viewport","top","left","origin","Math","max","transformOrigin","marginTop","addStyle","cssText","Object","entries","key","getOuterWidth","margin","HTMLElement","getComputedStyle","parseFloat","marginLeft","marginRight","relativePosition","targetHeight","alignOverlay","overlay","appendTo","calculateMinWidth","minWidth","isElement","nodeType","nodeName","toElement","hasOwnProperty","current","el","nativeElement","child","Error","calculatedScrollbarHeight","calculateScrollbarHeight","borderTopWidth","borderBottomWidth","scrollDiv","overflow","position","scrollbarHeight","calculatedScrollbarWidth","calculateScrollbarWidth","borderLeftWidth","borderRightWidth","scrollbarWidth","clearSelection","getSelection","selection","empty","removeAllRanges","rangeCount","getRangeAt","getClientRects","length","setAttributes","attributes","computedStyles","styles","$attrs","reduce","cv","v","push","_cv","Array","isArray","map","_k","_v","toLowerCase","concat","c","matchedEvent","match","addEventListener","Set","children","append","createStyleAsString","css","options","s","k","createStyleTag","container","head","fadeIn","duration","opacity","last","Date","tick","getTime","requestAnimationFrame","setTimeout","fadeOut","interval","gap","fading","setInterval","clearInterval","toString","find","selector","from","querySelectorAll","findSingle","matches","querySelector","focus","activeElement","getAttribute","isNaN","resolveUserAgent","ua","userAgent","exec","indexOf","browser","version","getBrowser","matched","getBrowserLanguage","languages","language","getCSSProperty","inline","getCursorOffset","prevText","nextText","currentText","ghostDiv","pointerEvents","padding","border","overflowWrap","whiteSpace","lineHeight","innerHTML","ghostSpan","textContent","text","createTextNode","offsetLeft","offsetTop","abs","getFocusableElements","focusableElements","visibleFocusableElements","focusableElement","getFirstFocusableElement","getHeight","paddingTop","paddingBottom","getHiddenElementOuterHeight","elementHeight","getHiddenElementOuterWidth","elementWidth","getParentNode","parent","parentNode","ShadowRoot","host","getIndex","childNodes","num","i","getInnerWidth","borderLeft","borderRight","getLastFocusableElement","getNextElementSibling","nextElement","nextElementSibling","getNextFocusableElement","index","findIndex","nextIndex","getOffset","rect","getOuterHeight","marginBottom","getParents","parents","getPreviousElementSibling","previousElement","previousElementSibling","getScrollableParents","scrollableParents","overflowRegex","overflowCheck","node","styleDeclaration","err","scrollSelectors","dataset","selectors","isExist","getTargetElement","currentElement","parentElement","isFunction","obj","constructor","call","apply","getUserAgent","getWidth","paddingLeft","paddingRight","hasCSSAnimation","animationDuration","hasCSSTransition","transitionDuration","invokeElementMethod","methodName","args","isAndroid","isAttributeEquals","isAttributeNotEquals","isClickable","targetNode","closest","isClient","isFocusableElement","isVisible","isHidden","isIOS","isRTL","direction","isServer","isTouchDevice","maxTouchPoints","msMaxTouchPoints","nestedPosition","level","parentItem","elementOffset","sublistWidth","sublistHeight","itemOuterWidth","itemOuterHeight","Element","prototype","removeStyleTag","error","scrollInView","item","borderTopValue","borderTop","paddingTopValue","containerRect","itemRect","offset","scroll","itemHeight","attribute","setCSSProperty","priority"],"sources":["../../src/dom/methods/hasClass.ts","../../src/dom/methods/addClass.ts","../../src/dom/methods/calculateBodyScrollbarWidth.ts","../../src/dom/methods/getCSSVariableByRegex.ts","../../src/dom/helpers/blockBodyScroll.ts","../../src/dom/helpers/saveAs.ts","../../src/dom/helpers/exportCSV.ts","../../src/dom/methods/removeClass.ts","../../src/dom/helpers/unblockBodyScroll.ts","../../src/dom/methods/getHiddenElementDimensions.ts","../../src/dom/methods/getViewport.ts","../../src/dom/methods/getWindowScrollLeft.ts","../../src/dom/methods/getWindowScrollTop.ts","../../src/dom/methods/absolutePosition.ts","../../src/dom/methods/addStyle.ts","../../src/dom/methods/getOuterWidth.ts","../../src/dom/methods/relativePosition.ts","../../src/dom/methods/alignOverlay.ts","../../src/dom/methods/isElement.ts","../../src/dom/methods/toElement.ts","../../src/dom/methods/appendChild.ts","../../src/dom/methods/calculateScrollbarHeight.ts","../../src/dom/methods/calculateScrollbarWidth.ts","../../src/dom/methods/clearSelection.ts","../../src/dom/methods/setAttributes.ts","../../src/dom/methods/createElement.ts","../../src/dom/methods/createStyleAsString.ts","../../src/dom/methods/createStyleTag.ts","../../src/dom/methods/fadeIn.ts","../../src/dom/methods/fadeOut.ts","../../src/dom/methods/find.ts","../../src/dom/methods/findSingle.ts","../../src/dom/methods/focus.ts","../../src/dom/methods/getAttribute.ts","../../src/dom/methods/resolveUserAgent.ts","../../src/dom/methods/getBrowser.ts","../../src/dom/methods/getBrowserLanguage.ts","../../src/dom/methods/getCSSProperty.ts","../../src/dom/methods/getCursorOffset.ts","../../src/dom/methods/getFocusableElements.ts","../../src/dom/methods/getFirstFocusableElement.ts","../../src/dom/methods/getHeight.ts","../../src/dom/methods/getHiddenElementOuterHeight.ts","../../src/dom/methods/getHiddenElementOuterWidth.ts","../../src/dom/methods/getParentNode.ts","../../src/dom/methods/getIndex.ts","../../src/dom/methods/getInnerWidth.ts","../../src/dom/methods/getLastFocusableElement.ts","../../src/dom/methods/getNextElementSibling.ts","../../src/dom/methods/getNextFocusableElement.ts","../../src/dom/methods/getOffset.ts","../../src/dom/methods/getOuterHeight.ts","../../src/dom/methods/getParents.ts","../../src/dom/methods/getPreviousElementSibling.ts","../../src/dom/methods/getScrollableParents.ts","../../src/dom/methods/getSelection.ts","../../src/dom/methods/isExist.ts","../../src/dom/methods/getTargetElement.ts","../../src/dom/methods/getUserAgent.ts","../../src/dom/methods/getWidth.ts","../../src/dom/methods/hasCSSAnimation.ts","../../src/dom/methods/hasCSSTransition.ts","../../src/dom/methods/invokeElementMethod.ts","../../src/dom/methods/isAndroid.ts","../../src/dom/methods/isAttributeEquals.ts","../../src/dom/methods/isAttributeNotEquals.ts","../../src/dom/methods/isClickable.ts","../../src/dom/methods/isClient.ts","../../src/dom/methods/isFocusableElement.ts","../../src/dom/methods/isVisible.ts","../../src/dom/methods/isHidden.ts","../../src/dom/methods/isIOS.ts","../../src/dom/methods/isRTL.ts","../../src/dom/methods/isServer.ts","../../src/dom/methods/isTouchDevice.ts","../../src/dom/methods/nestedPosition.ts","../../src/dom/methods/remove.ts","../../src/dom/methods/removeChild.ts","../../src/dom/methods/removeStyleTag.ts","../../src/dom/methods/scrollInView.ts","../../src/dom/methods/setAttribute.ts","../../src/dom/methods/setCSSProperty.ts"],"sourcesContent":["export default function hasClass(element: Element, className: string): boolean {\n    if (element) {\n        if (element.classList) return element.classList.contains(className);\n        else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n    }\n\n    return false;\n}\n","import hasClass from './hasClass';\n\nexport default function addClass(element: Element, className: string | string[]): void {\n    if (element && className) {\n        const fn = (_className: string) => {\n            if (!hasClass(element, _className)) {\n                if (element.classList) element.classList.add(_className);\n                else element.className += ' ' + _className;\n            }\n        };\n\n        [className]\n            .flat()\n            .filter(Boolean)\n            .forEach((_classNames) => _classNames.split(' ').forEach(fn));\n    }\n}\n","export default function calculateBodyScrollbarWidth(): number {\n    return window.innerWidth - document.documentElement.offsetWidth;\n}\n","export default function getCSSVariableByRegex(variableRegex: RegExp): { name: string | undefined; value: string | undefined } | null {\n    for (const sheet of document?.styleSheets) {\n        try {\n            for (const rule of sheet?.cssRules) {\n                for (const property of (rule as CSSStyleRule)?.style) {\n                    if (variableRegex.test(property)) {\n                        return { name: property, value: (rule as CSSStyleRule).style.getPropertyValue(property).trim() };\n                    }\n                }\n            }\n        } catch {}\n    }\n\n    return null;\n}\n","import addClass from '../methods/addClass';\nimport calculateBodyScrollbarWidth from '../methods/calculateBodyScrollbarWidth';\nimport getCSSVariableByRegex from '../methods/getCSSVariableByRegex';\n\nexport default function blockBodyScroll(className: string = 'p-overflow-hidden'): void {\n    const variableData = getCSSVariableByRegex(/-scrollbar-width$/);\n    variableData?.name && document.body.style.setProperty(variableData.name, calculateBodyScrollbarWidth() + 'px');\n    addClass(document.body, className);\n}\n","export default function saveAs(file: { name: string; src: string }): boolean {\n    if (file) {\n        let link = document.createElement('a');\n\n        if (link.download !== undefined) {\n            const { name, src } = file;\n\n            link.setAttribute('href', src);\n            link.setAttribute('download', name);\n            link.style.display = 'none';\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n\n            return true;\n        }\n    }\n\n    return false;\n}\n","import saveAs from './saveAs';\n\nexport default function exportCSV(csv: any, filename: string): void {\n    let blob = new Blob([csv], {\n        type: 'application/csv;charset=utf-8;'\n    });\n\n    if ((window.navigator as any).msSaveOrOpenBlob) {\n        (navigator as any).msSaveOrOpenBlob(blob, filename + '.csv');\n    } else {\n        const isDownloaded = saveAs({ name: filename + '.csv', src: URL.createObjectURL(blob) });\n\n        if (!isDownloaded) {\n            csv = 'data:text/csv;charset=utf-8,' + csv;\n            window.open(encodeURI(csv));\n        }\n    }\n}\n","export default function removeClass(element: Element, className: string | string[]): void {\n    if (element && className) {\n        const fn = (_className: string) => {\n            if (element.classList) element.classList.remove(_className);\n            else element.className = element.className.replace(new RegExp('(^|\\\\b)' + _className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        };\n\n        [className]\n            .flat()\n            .filter(Boolean)\n            .forEach((_classNames) => _classNames.split(' ').forEach(fn));\n    }\n}\n","import getCSSVariableByRegex from '../methods/getCSSVariableByRegex';\nimport removeClass from '../methods/removeClass';\n\nexport default function unblockBodyScroll(className: string = 'p-overflow-hidden'): void {\n    const variableData = getCSSVariableByRegex(/-scrollbar-width$/);\n    variableData?.name && document.body.style.removeProperty(variableData.name);\n    removeClass(document.body, className);\n}\n","export default function getHiddenElementDimensions(element?: HTMLElement): { width: number; height: number } {\n    let dimensions: { width: number; height: number } = { width: 0, height: 0 };\n\n    if (element) {\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        dimensions.width = element.offsetWidth;\n        dimensions.height = element.offsetHeight;\n        element.style.display = 'none';\n        element.style.visibility = 'visible';\n    }\n\n    return dimensions;\n}\n","export default function getViewport(): { width: number; height: number } {\n    let win = window,\n        d = document,\n        e = d.documentElement,\n        g = d.getElementsByTagName('body')[0],\n        w = win.innerWidth || e.clientWidth || g.clientWidth,\n        h = win.innerHeight || e.clientHeight || g.clientHeight;\n\n    return { width: w, height: h };\n}\n","export default function getWindowScrollLeft(): number {\n    let doc = document.documentElement;\n\n    return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n}\n","export default function getWindowScrollTop(): number {\n    let doc = document.documentElement;\n\n    return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n}\n","import getCSSVariableByRegex from './getCSSVariableByRegex';\nimport getHiddenElementDimensions from './getHiddenElementDimensions';\nimport getViewport from './getViewport';\nimport getWindowScrollLeft from './getWindowScrollLeft';\nimport getWindowScrollTop from './getWindowScrollTop';\n\nexport default function absolutePosition(element: HTMLElement, target: HTMLElement, gutter: boolean = true): void {\n    if (element) {\n        const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);\n        const elementOuterHeight = elementDimensions.height;\n        const elementOuterWidth = elementDimensions.width;\n        const targetOuterHeight = target.offsetHeight;\n        const targetOuterWidth = target.offsetWidth;\n        const targetOffset = target.getBoundingClientRect();\n        const windowScrollTop = getWindowScrollTop();\n        const windowScrollLeft = getWindowScrollLeft();\n        const viewport = getViewport();\n        let top,\n            left,\n            origin = 'top';\n\n        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {\n            top = targetOffset.top + windowScrollTop - elementOuterHeight;\n            origin = 'bottom';\n\n            if (top < 0) {\n                top = windowScrollTop;\n            }\n        } else {\n            top = targetOuterHeight + targetOffset.top + windowScrollTop;\n        }\n\n        if (targetOffset.left + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);\n        else left = targetOffset.left + windowScrollLeft;\n\n        element.style.top = top + 'px';\n        element.style.left = left + 'px';\n        element.style.transformOrigin = origin;\n        gutter && (element.style.marginTop = origin === 'bottom' ? `calc(${getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? '2px'} * -1)` : (getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? ''));\n    }\n}\n","export default function addStyle(element: HTMLElement, style: string | object): void {\n    if (element) {\n        if (typeof style === 'string') {\n            element.style.cssText = style;\n        } else {\n            Object.entries(style || {}).forEach(([key, value]: [string, string]) => ((element.style as any)[key] = value));\n        }\n    }\n}\n","export default function getOuterWidth(element: unknown, margin?: boolean): number {\n    if (element instanceof HTMLElement) {\n        let width = element.offsetWidth;\n\n        if (margin) {\n            let style = getComputedStyle(element);\n\n            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n        }\n\n        return width;\n    }\n\n    return 0;\n}\n","import getCSSVariableByRegex from './getCSSVariableByRegex';\nimport getHiddenElementDimensions from './getHiddenElementDimensions';\nimport getViewport from './getViewport';\n\nexport default function relativePosition(element: HTMLElement, target: HTMLElement, gutter: boolean = true): void {\n    if (element) {\n        const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);\n        const targetHeight = target.offsetHeight;\n        const targetOffset = target.getBoundingClientRect();\n        const viewport = getViewport();\n        let top,\n            left,\n            origin = 'top';\n\n        if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {\n            top = -1 * elementDimensions.height;\n            origin = 'bottom';\n\n            if (targetOffset.top + top < 0) {\n                top = -1 * targetOffset.top;\n            }\n        } else {\n            top = targetHeight;\n        }\n\n        if (elementDimensions.width > viewport.width) {\n            // element wider then viewport and cannot fit on screen (align at left side of viewport)\n            left = targetOffset.left * -1;\n        } else if (targetOffset.left + elementDimensions.width > viewport.width) {\n            // element wider then viewport but can be fit on screen (align at right side of viewport)\n            left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;\n        } else {\n            // element fits on screen (align with target)\n            left = 0;\n        }\n\n        element.style.top = top + 'px';\n        element.style.left = left + 'px';\n        element.style.transformOrigin = origin;\n        gutter && (element.style.marginTop = origin === 'bottom' ? `calc(${getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? '2px'} * -1)` : (getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? ''));\n    }\n}\n","import absolutePosition from './absolutePosition';\nimport getOuterWidth from './getOuterWidth';\nimport relativePosition from './relativePosition';\n\nexport default function alignOverlay(overlay: HTMLElement, target: HTMLElement, appendTo: string, calculateMinWidth: boolean = true) {\n    if (overlay && target) {\n        if (appendTo === 'self') {\n            relativePosition(overlay, target);\n        } else {\n            calculateMinWidth && (overlay.style.minWidth = getOuterWidth(target) + 'px');\n            absolutePosition(overlay, target);\n        }\n    }\n}\n","export default function isElement(element: any): boolean {\n    return typeof HTMLElement === 'object' ? element instanceof HTMLElement : element && typeof element === 'object' && element !== null && element.nodeType === 1 && typeof element.nodeName === 'string';\n}\n","import isElement from './isElement';\n\nexport default function toElement(element: any): Element | undefined {\n    let target = element;\n\n    if (element && typeof element === 'object') {\n        if (element.hasOwnProperty('current')) {\n            // For React\n            target = element.current;\n        } else if (element.hasOwnProperty('el')) {\n            if (element.el.hasOwnProperty('nativeElement')) {\n                // For Angular\n                target = element.el.nativeElement;\n            } else {\n                // For Vue\n                target = element.el;\n            }\n        }\n    }\n\n    return isElement(target) ? target : undefined;\n}\n","import toElement from './toElement';\n\nexport default function appendChild(element: unknown, child: Node) {\n    const target: Element | undefined = toElement(element);\n\n    if (target) target.appendChild(child);\n    else throw new Error('Cannot append ' + child + ' to ' + element);\n}\n","import addStyle from './addStyle';\n\nlet calculatedScrollbarHeight: number | undefined = undefined;\n\nexport default function calculateScrollbarHeight(element?: HTMLElement): number {\n    if (element) {\n        let style = getComputedStyle(element);\n        return element.offsetHeight - element.clientHeight - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth);\n    } else {\n        if (calculatedScrollbarHeight != null) return calculatedScrollbarHeight;\n\n        let scrollDiv = document.createElement('div');\n\n        addStyle(scrollDiv, {\n            width: '100px',\n            height: '100px',\n            overflow: 'scroll',\n            position: 'absolute',\n            top: '-9999px'\n        });\n        document.body.appendChild(scrollDiv);\n\n        let scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;\n\n        document.body.removeChild(scrollDiv);\n\n        calculatedScrollbarHeight = scrollbarHeight;\n\n        return scrollbarHeight;\n    }\n}\n","import addStyle from './addStyle';\n\nlet calculatedScrollbarWidth: number | undefined = undefined;\n\nexport default function calculateScrollbarWidth(element?: HTMLElement): number {\n    if (element) {\n        let style = getComputedStyle(element);\n        return element.offsetWidth - element.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);\n    } else {\n        if (calculatedScrollbarWidth != null) return calculatedScrollbarWidth;\n\n        let scrollDiv = document.createElement('div');\n\n        addStyle(scrollDiv, {\n            width: '100px',\n            height: '100px',\n            overflow: 'scroll',\n            position: 'absolute',\n            top: '-9999px'\n        });\n        document.body.appendChild(scrollDiv);\n\n        let scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n        document.body.removeChild(scrollDiv);\n\n        calculatedScrollbarWidth = scrollbarWidth;\n\n        return scrollbarWidth;\n    }\n}\n","export default function clearSelection(): void {\n    if (window.getSelection) {\n        const selection: any = window.getSelection() || {};\n\n        if (selection.empty) {\n            selection.empty();\n        } else if (selection.removeAllRanges && selection.rangeCount > 0 && selection.getRangeAt(0).getClientRects().length > 0) {\n            selection.removeAllRanges();\n        }\n    }\n}\n","import isElement from './isElement';\n\nexport default function setAttributes(element: HTMLElement, attributes: { [key: string]: any } = {}): void {\n    if (isElement(element)) {\n        const computedStyles = (rule: string, value: any): string[] => {\n            const styles = (element as any)?.$attrs?.[rule] ? [(element as any)?.$attrs?.[rule]] : [];\n\n            return [value].flat().reduce((cv, v) => {\n                if (v !== null && v !== undefined) {\n                    const type = typeof v;\n\n                    if (type === 'string' || type === 'number') {\n                        cv.push(v);\n                    } else if (type === 'object') {\n                        const _cv = Array.isArray(v) ? computedStyles(rule, v) : Object.entries(v).map(([_k, _v]) => (rule === 'style' && (!!_v || _v === 0) ? `${_k.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()}:${_v}` : !!_v ? _k : undefined));\n\n                        cv = _cv.length ? cv.concat(_cv.filter((c) => !!c)) : cv;\n                    }\n                }\n\n                return cv;\n            }, styles);\n        };\n\n        Object.entries(attributes).forEach(([key, value]) => {\n            if (value !== undefined && value !== null) {\n                const matchedEvent = key.match(/^on(.+)/);\n\n                if (matchedEvent) {\n                    element.addEventListener(matchedEvent[1].toLowerCase(), value);\n                } else if (key === 'p-bind' || key === 'pBind') {\n                    setAttributes(element, value);\n                } else {\n                    value = key === 'class' ? [...new Set(computedStyles('class', value))].join(' ').trim() : key === 'style' ? computedStyles('style', value).join(';').trim() : value;\n                    ((element as any).$attrs = (element as any).$attrs || {}) && ((element as any).$attrs[key] = value);\n                    element.setAttribute(key, value);\n                }\n            }\n        });\n    }\n}\n","import setAttributes from './setAttributes';\n\nexport default function createElement(type: string, attributes: { [key: string]: any } = {}, ...children: (string | Node)[]): HTMLElement | undefined {\n    if (type) {\n        const element = document.createElement(type);\n\n        setAttributes(element, attributes);\n        element.append(...children);\n\n        return element;\n    }\n\n    return undefined;\n}\n","export default function createStyleAsString(css: string, options: any = {}) {\n    return css ? `'<style ${Object.entries(options).reduce((s, [k, v]) => s + `${k}=\"${v}\"`, ' ')}>${css}</style>'` : '';\n}\n","import setAttributes from './setAttributes';\n\nexport default function createStyleTag(attributes: { [key: string]: any } = {}, container: Element): HTMLStyleElement {\n    let element = document.createElement('style');\n    setAttributes(element, attributes);\n\n    if (!container) {\n        container = document.head;\n    }\n\n    container.appendChild(element);\n\n    return element;\n}\n","export default function fadeIn(element: HTMLElement, duration: number): void {\n    if (element) {\n        element.style.opacity = '0';\n\n        let last = +new Date();\n        let opacity = '0';\n\n        let tick = function () {\n            opacity = `${+element.style.opacity + (new Date().getTime() - last) / duration}`;\n            element.style.opacity = opacity;\n            last = +new Date();\n\n            if (+opacity < 1) {\n                (!!window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);\n            }\n        };\n\n        tick();\n    }\n}\n","export default function fadeOut(element: HTMLElement, duration: number): void {\n    if (element) {\n        let opacity = 1,\n            interval = 50,\n            gap = interval / duration;\n\n        let fading = setInterval(() => {\n            opacity -= gap;\n\n            if (opacity <= 0) {\n                opacity = 0;\n                clearInterval(fading);\n            }\n\n            element.style.opacity = opacity.toString();\n        }, interval);\n    }\n}\n","import isElement from './isElement';\n\nexport default function find(element: Element, selector: string): Element[] {\n    return isElement(element) ? Array.from(element.querySelectorAll(selector)) : [];\n}\n","import isElement from './isElement';\n\nexport default function findSingle(element: Element, selector: string): Element | null {\n    return isElement(element) ? (element.matches(selector) ? element : element.querySelector(selector)) : null;\n}\n","export default function focus(element: HTMLElement, options?: FocusOptions): void {\n    element && document.activeElement !== element && element.focus(options);\n}\n","import isElement from './isElement';\n\nexport default function getAttribute(element: Element, name: string): any {\n    if (isElement(element)) {\n        const value = element.getAttribute(name);\n\n        if (!isNaN(value as any)) {\n            return +(value as string);\n        }\n\n        if (value === 'true' || value === 'false') {\n            return value === 'true';\n        }\n\n        return value;\n    }\n\n    return undefined;\n}\n","export default function resolveUserAgent(): { browser: string | undefined; version: string | undefined } {\n    let ua = navigator.userAgent.toLowerCase();\n    let match = /(chrome)[ ]([\\w.]+)/.exec(ua) || /(webkit)[ ]([\\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\\w.]+)/.exec(ua) || /(msie) ([\\w.]+)/.exec(ua) || (ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua)) || [];\n\n    return {\n        browser: match[1] || '',\n        version: match[2] || '0'\n    };\n}\n","import resolveUserAgent from './resolveUserAgent';\n\ntype BrowserType = {\n    [key: string]: string | boolean | undefined;\n};\n\nlet browser: BrowserType | null = null;\n\nexport default function getBrowser(): BrowserType {\n    if (!browser) {\n        browser = {};\n\n        let matched = resolveUserAgent();\n\n        if (matched.browser) {\n            browser[matched.browser] = true;\n            browser['version'] = matched.version;\n        }\n\n        if (browser['chrome']) {\n            browser['webkit'] = true;\n        } else if (browser['webkit']) {\n            browser['safari'] = true;\n        }\n    }\n\n    return browser;\n}\n","export default function getBrowserLanguage(): string {\n    return (navigator.languages && navigator.languages.length && navigator.languages[0]) || navigator.language || 'en';\n}\n","export default function getCSSProperty(element?: HTMLElement, property?: string, inline?: boolean): string | null {\n    if (element && property) {\n        return inline ? element?.style?.getPropertyValue(property) : getComputedStyle(element).getPropertyValue(property);\n    }\n\n    return null;\n}\n","export default function getCursorOffset(element: Element, prevText: string, nextText: string, currentText: string): { top: number | string; left: number | string } {\n    if (element) {\n        let style = getComputedStyle(element);\n        let ghostDiv = document.createElement('div');\n\n        ghostDiv.style.position = 'absolute';\n        ghostDiv.style.top = '0px';\n        ghostDiv.style.left = '0px';\n        ghostDiv.style.visibility = 'hidden';\n        ghostDiv.style.pointerEvents = 'none';\n        ghostDiv.style.overflow = style.overflow;\n        ghostDiv.style.width = style.width;\n        ghostDiv.style.height = style.height;\n        ghostDiv.style.padding = style.padding;\n        ghostDiv.style.border = style.border;\n        ghostDiv.style.overflowWrap = style.overflowWrap;\n        ghostDiv.style.whiteSpace = style.whiteSpace;\n        ghostDiv.style.lineHeight = style.lineHeight;\n        ghostDiv.innerHTML = prevText.replace(/\\r\\n|\\r|\\n/g, '<br />');\n\n        let ghostSpan = document.createElement('span');\n\n        ghostSpan.textContent = currentText;\n        ghostDiv.appendChild(ghostSpan);\n\n        let text = document.createTextNode(nextText);\n\n        ghostDiv.appendChild(text);\n        document.body.appendChild(ghostDiv);\n\n        const { offsetLeft, offsetTop, clientHeight } = ghostSpan;\n\n        document.body.removeChild(ghostDiv);\n\n        return {\n            left: Math.abs(offsetLeft - element.scrollLeft),\n            top: Math.abs(offsetTop - element.scrollTop) + clientHeight\n        };\n    }\n\n    return {\n        top: 'auto',\n        left: 'auto'\n    };\n}\n","import find from './find';\n\nexport default function getFocusableElements(element: Element, selector: string = ''): Element[] {\n    let focusableElements = find(\n        element,\n        `button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`\n    );\n\n    let visibleFocusableElements: Element[] = [];\n\n    for (let focusableElement of focusableElements) {\n        if (getComputedStyle(focusableElement).display != 'none' && getComputedStyle(focusableElement).visibility != 'hidden') visibleFocusableElements.push(focusableElement);\n    }\n\n    return visibleFocusableElements;\n}\n","import getFocusableElements from './getFocusableElements';\n\nexport default function getFirstFocusableElement(element: Element, selector?: string): Element | null {\n    const focusableElements = getFocusableElements(element, selector);\n\n    return focusableElements.length > 0 ? focusableElements[0] : null;\n}\n","export default function getHeight(element: HTMLElement): number {\n    if (element) {\n        let height = element.offsetHeight;\n        let style = getComputedStyle(element);\n\n        height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n\n        return height;\n    }\n\n    return 0;\n}\n","export default function getHiddenElementOuterHeight(element: HTMLElement): number {\n    if (element) {\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        let elementHeight = element.offsetHeight;\n\n        element.style.display = 'none';\n        element.style.visibility = 'visible';\n\n        return elementHeight;\n    }\n\n    return 0;\n}\n","export default function getHiddenElementOuterWidth(element: HTMLElement): number {\n    if (element) {\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        let elementWidth = element.offsetWidth;\n\n        element.style.display = 'none';\n        element.style.visibility = 'visible';\n\n        return elementWidth;\n    }\n\n    return 0;\n}\n","export default function getParentNode(element: Node): ParentNode | null {\n    if (element) {\n        let parent = element.parentNode;\n\n        if (parent && parent instanceof ShadowRoot && parent.host) {\n            parent = parent.host;\n        }\n\n        return parent;\n    }\n\n    return null;\n}\n","import getParentNode from './getParentNode';\n\nexport default function getIndex(element: HTMLElement): number {\n    if (element) {\n        let children = getParentNode(element)?.childNodes;\n        let num = 0;\n\n        if (children) {\n            for (let i = 0; i < children.length; i++) {\n                if (children[i] === element) return num;\n                if (children[i].nodeType === 1) num++;\n            }\n        }\n    }\n\n    return -1;\n}\n","export default function getInnerWidth(element: HTMLElement): number {\n    if (element) {\n        let width = element.offsetWidth;\n        let style = getComputedStyle(element);\n\n        width -= parseFloat(style.borderLeft) + parseFloat(style.borderRight);\n\n        return width;\n    }\n\n    return 0;\n}\n","import getFocusableElements from './getFocusableElements';\n\nexport default function getLastFocusableElement(element: Element, selector?: string): Element | null {\n    const focusableElements = getFocusableElements(element, selector);\n\n    return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;\n}\n","export default function getNextElementSibling(element: Element, selector: string): Element | null {\n    let nextElement = element.nextElementSibling;\n\n    while (nextElement) {\n        if (nextElement.matches(selector)) {\n            return nextElement;\n        } else {\n            nextElement = nextElement.nextElementSibling;\n        }\n    }\n\n    return null;\n}\n","import getFocusableElements from './getFocusableElements';\n\nexport default function getNextFocusableElement(container: Element, element: Element, selector?: string): Element | null {\n    const focusableElements: Element[] = getFocusableElements(container, selector);\n    const index = focusableElements.length > 0 ? focusableElements.findIndex((el) => el === element) : -1;\n    const nextIndex = index > -1 && focusableElements.length >= index + 1 ? index + 1 : -1;\n\n    return nextIndex > -1 ? focusableElements[nextIndex] : null;\n}\n","export default function getOffset(element?: Element | null): { top: number | string; left: number | string } {\n    if (element) {\n        let rect = element.getBoundingClientRect();\n\n        return {\n            top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),\n            left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)\n        };\n    }\n\n    return {\n        top: 'auto',\n        left: 'auto'\n    };\n}\n","export default function getOuterHeight(element: HTMLElement, margin?: boolean): number {\n    if (element) {\n        let height = element.offsetHeight;\n\n        if (margin) {\n            let style = getComputedStyle(element);\n\n            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n        }\n\n        return height;\n    }\n\n    return 0;\n}\n","import getParentNode from './getParentNode';\n\nexport default function getParents(element: Node, parents: ParentNode[] = []): ParentNode[] {\n    const parent = getParentNode(element);\n\n    return parent === null ? parents : getParents(parent, parents.concat([parent]));\n}\n","export default function getPreviousElementSibling(element: Element, selector: string): Element | null {\n    let previousElement = element.previousElementSibling;\n\n    while (previousElement) {\n        if (previousElement.matches(selector)) {\n            return previousElement;\n        } else {\n            previousElement = previousElement.previousElementSibling;\n        }\n    }\n\n    return null;\n}\n","import findSingle from './findSingle';\nimport getParents from './getParents';\n\nexport default function getScrollableParents(element: Element): Element[] {\n    let scrollableParents = [];\n\n    if (element) {\n        let parents = getParents(element) as HTMLElement[];\n        const overflowRegex = /(auto|scroll)/;\n\n        const overflowCheck = (node: Element) => {\n            try {\n                let styleDeclaration = window['getComputedStyle'](node, null);\n\n                return overflowRegex.test(styleDeclaration.getPropertyValue('overflow')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowX')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowY'));\n            } catch (err) {\n                return false;\n            }\n        };\n\n        for (let parent of parents) {\n            let scrollSelectors = parent.nodeType === 1 && parent.dataset['scrollselectors'];\n\n            if (scrollSelectors) {\n                let selectors = scrollSelectors.split(',');\n\n                for (let selector of selectors) {\n                    let el = findSingle(parent, selector);\n\n                    if (el && overflowCheck(el)) {\n                        scrollableParents.push(el);\n                    }\n                }\n            }\n\n            if (parent.nodeType !== 9 && overflowCheck(parent)) {\n                scrollableParents.push(parent);\n            }\n        }\n    }\n\n    return scrollableParents;\n}\n","export default function getSelection(): string | undefined {\n    if (window.getSelection) return (window.getSelection() as any).toString();\n    else if (document.getSelection) return (document.getSelection() as any).toString();\n\n    return undefined;\n}\n","import getParentNode from './getParentNode';\n\nexport default function isExist(element: Node): boolean {\n    return !!(element !== null && typeof element !== 'undefined' && element.nodeName && getParentNode(element));\n}\n","import isExist from './isExist';\nimport toElement from './toElement';\n\nexport default function getTargetElement(target: any, currentElement: Element): Window | Document | Element | null | undefined {\n    if (!target) return undefined;\n\n    switch (target) {\n        case 'document':\n            return document;\n        case 'window':\n            return window;\n        case 'body':\n            return document.body;\n        case '@next':\n            return currentElement?.nextElementSibling;\n        case '@prev':\n            return currentElement?.previousElementSibling;\n        case '@parent':\n            return currentElement?.parentElement;\n        case '@grandparent':\n            return currentElement?.parentElement?.parentElement;\n        default:\n            if (typeof target === 'string') {\n                return document.querySelector(target);\n            }\n\n            const isFunction = (obj: any): obj is Function => !!(obj && obj.constructor && obj.call && obj.apply);\n            const element = toElement(isFunction(target) ? target() : target);\n\n            return element?.nodeType === 9 || isExist(element as Element) ? element : undefined;\n    }\n}\n","export default function getUserAgent(): string {\n    return navigator.userAgent;\n}\n","export default function getWidth(element: HTMLElement): number {\n    if (element) {\n        let width = element.offsetWidth;\n        let style = getComputedStyle(element);\n\n        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);\n\n        return width;\n    }\n\n    return 0;\n}\n","export default function hasCSSAnimation(element: Element): boolean {\n    if (element) {\n        const style = getComputedStyle(element);\n        const animationDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');\n\n        return animationDuration > 0;\n    }\n\n    return false;\n}\n","export default function hasCSSTransition(element: Element): boolean {\n    if (element) {\n        const style = getComputedStyle(element);\n        const transitionDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');\n\n        return transitionDuration > 0;\n    }\n\n    return false;\n}\n","export default function invokeElementMethod(element: Element, methodName: string, args?: any[]): void {\n    (element as any)[methodName].apply(element, args);\n}\n","export default function isAndroid(): boolean {\n    return /(android)/i.test(navigator.userAgent);\n}\n","import getAttribute from './getAttribute';\nimport isElement from './isElement';\n\nexport default function isAttributeEquals(element: Element, name: string, value: any): boolean {\n    return isElement(element) ? getAttribute(element, name) === value : false;\n}\n","import isAttributeEquals from './isAttributeEquals';\n\nexport default function isAttributeNotEquals(element: Element, name: string, value: any): boolean {\n    return !isAttributeEquals(element, name, value);\n}\n","export default function isClickable(element: Element): boolean {\n    if (element) {\n        const targetNode = element.nodeName;\n        const parentNode = element.parentElement && element.parentElement.nodeName;\n\n        return (\n            targetNode === 'INPUT' ||\n            targetNode === 'TEXTAREA' ||\n            targetNode === 'BUTTON' ||\n            targetNode === 'A' ||\n            parentNode === 'INPUT' ||\n            parentNode === 'TEXTAREA' ||\n            parentNode === 'BUTTON' ||\n            parentNode === 'A' ||\n            !!element.closest('.p-button, .p-checkbox, .p-radiobutton') // @todo Add [data-pc-section=\"button\"]\n        );\n    }\n\n    return false;\n}\n","export default function isClient(): boolean {\n    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n}\n","import isElement from './isElement';\n\nexport default function isFocusableElement(element: unknown, selector: string = ''): boolean {\n    return isElement(element)\n        ? (element as Element).matches(`button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`)\n        : false;\n}\n","export default function isVisible(element?: HTMLElement): boolean {\n    return !!(element && element.offsetParent != null);\n}\n","import isVisible from './isVisible';\n\nexport default function isHidden(element: HTMLElement): boolean {\n    return !isVisible(element);\n}\n","export default function isIOS(): boolean {\n    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any)['MSStream'];\n}\n","export default function isRTL(element?: HTMLElement): boolean {\n    return element ? getComputedStyle(element).direction === 'rtl' : false;\n}\n","import isClient from './isClient';\n\nexport default function isServer(): boolean {\n    return !isClient();\n}\n","export default function isTouchDevice(): boolean {\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || (navigator as any).msMaxTouchPoints > 0;\n}\n","import calculateScrollbarWidth from './calculateScrollbarWidth';\nimport getHiddenElementOuterHeight from './getHiddenElementOuterHeight';\nimport getHiddenElementOuterWidth from './getHiddenElementOuterWidth';\nimport getOffset from './getOffset';\nimport getOuterHeight from './getOuterHeight';\nimport getOuterWidth from './getOuterWidth';\nimport getViewport from './getViewport';\n\nexport default function nestedPosition(element: HTMLElement, level: number): void {\n    if (element) {\n        const parentItem = element.parentElement;\n        const elementOffset = getOffset(parentItem);\n        const viewport = getViewport();\n        const sublistWidth = element.offsetParent ? element.offsetWidth : getHiddenElementOuterWidth(element);\n        const sublistHeight = element.offsetParent ? element.offsetHeight : getHiddenElementOuterHeight(element);\n        const itemOuterWidth = getOuterWidth(parentItem?.children?.[0]);\n        const itemOuterHeight = getOuterHeight(parentItem?.children?.[0] as HTMLElement);\n\n        let left: string = '';\n        let top: string = '';\n\n        if ((elementOffset.left as number) + itemOuterWidth + sublistWidth > viewport.width - calculateScrollbarWidth()) {\n            if ((elementOffset.left as number) < sublistWidth) {\n                // for too small screens\n                if (level % 2 === 1) {\n                    left = (elementOffset.left as number) ? '-' + (elementOffset.left as number) + 'px' : '100%';\n                } else if (level % 2 === 0) {\n                    left = viewport.width - sublistWidth - calculateScrollbarWidth() + 'px';\n                }\n            } else {\n                left = '-100%';\n            }\n        } else {\n            left = '100%';\n        }\n\n        // getBoundingClientRect returns a top position from the current visible viewport area\n        if (element.getBoundingClientRect().top + itemOuterHeight + sublistHeight > viewport.height) {\n            top = `-${sublistHeight - itemOuterHeight}px`;\n        } else {\n            top = '0px';\n        }\n\n        element.style.top = top;\n        element.style.left = left;\n    }\n}\n","export default function remove(element: Element) {\n    if (element) {\n        if (!('remove' in Element.prototype)) element.parentNode?.removeChild(element);\n        else element.remove();\n    }\n}\n","import toElement from './toElement';\n\nexport default function removeChild(element: unknown, child: Node) {\n    const target = toElement(element);\n\n    if (target) target.removeChild(child);\n    else throw new Error('Cannot remove ' + child + ' from ' + element);\n}\n","import isExist from './isExist';\n\nexport default function removeStyleTag(element: Node): Node | null {\n    if (isExist(element)) {\n        try {\n            element.parentNode?.removeChild(element);\n        } catch (error) {\n            // style element may have already been removed in a fast refresh\n        }\n\n        return null;\n    }\n\n    return element;\n}\n","import getOuterHeight from './getOuterHeight';\n\nexport default function scrollInView(container: HTMLElement, item: HTMLElement): void {\n    let borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');\n    let borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;\n    let paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');\n    let paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;\n    let containerRect = container.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    let offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;\n    let scroll = container.scrollTop;\n    let elementHeight = container.clientHeight;\n    let itemHeight = getOuterHeight(item);\n\n    if (offset < 0) {\n        container.scrollTop = scroll + offset;\n    } else if (offset + itemHeight > elementHeight) {\n        container.scrollTop = scroll + offset - elementHeight + itemHeight;\n    }\n}\n","import isElement from './isElement';\n\nexport default function setAttribute(element: HTMLElement, attribute: string = '', value: any): void {\n    if (isElement(element) && value !== null && value !== undefined) {\n        element.setAttribute(attribute, value);\n    }\n}\n","export default function setCSSProperty(element?: HTMLElement, property?: string, value: any = null, priority?: string): void {\n    property && element?.style?.setProperty(property, value, priority);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}